# 32.最长有序括号

[题目链接 - 32.最长有序括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

原字符串遍历到任意时刻都只会出现三种情况：

1、左括号比右括号多  
2、右括号比左括号多  
3、两者一样多

因此思路在于将字符串分为多个区段进行计数，保证每个区段内的左右括号数量一样多，且区段有效。

例如：  
(()())))()(可以划出两个区段  
【(()())】))【()】(

(())()()可以划分出三个区段  
【(())】【()】【()】

只对划分好的区段进行计数；用former变量记录前一个区段的长度；若两个区段连续，即中间没有多余的右括号，则合并区段长度。  

<br>

但是这样计数会出现一个问题，即当前计算的字符串可能还没来得及形成区段就结束了，例如：  
【()】((()()()()((

很明显还未形成区段的部分包含更多的有效括号。  

就像之前说的，一段未形成区段的字符串只可能有1、2两种情况，那么如果从左往右遍历无法形成区段，则从右往左一定可以形成至少一个区段。  

所以整体思路是进行两边遍历，取两次遍历结果的最大值。  